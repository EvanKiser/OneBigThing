{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.closeSession = exports.request = exports.sessions = void 0;\n\nconst http2 = require(\"http2\");\n\nconst zlib = require(\"zlib\");\n\nconst url_1 = require(\"url\");\n\nconst qs = require(\"qs\");\n\nconst extend = require(\"extend\");\n\nconst stream_1 = require(\"stream\");\n\nconst util = require(\"util\");\n\nconst process = require(\"process\");\n\nconst common_1 = require(\"gaxios/build/src/common\");\n\nconst {\n  HTTP2_HEADER_CONTENT_ENCODING,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_STATUS\n} = http2.constants;\nconst DEBUG = !!process.env.HTTP2_DEBUG;\n/**\n * List of sessions current in use.\n * @private\n */\n\nexports.sessions = {};\nlet warned = false;\n/**\n * Public method to make an http2 request.\n * @param config - Request options.\n */\n\nasync function request(config) {\n  // Make sure users know this API is unstable\n  if (!warned) {\n    const message = `\n      The HTTP/2 API in googleapis is unstable! This is an early implementation\n      that should not be used in production.  It may change in unpredictable\n      ways. Please only use this for experimentation.\n    `;\n    process.emitWarning(message, 'GOOG_HTTP2');\n    warned = true;\n  }\n\n  const opts = extend(true, {}, config);\n  opts.validateStatus = opts.validateStatus || validateStatus;\n  opts.responseType = opts.responseType || 'json';\n  const url = new url_1.URL(opts.url); // Check for an existing session to this host, or go create a new one.\n\n  const sessionData = _getClient(url.host); // Since we're using this session, clear the timeout handle to ensure\n  // it stays in memory and connected for a while further.\n\n\n  if (sessionData.timeoutHandle !== undefined) {\n    clearTimeout(sessionData.timeoutHandle);\n  } // Assemble the querystring based on config.params.  We're using the\n  // `qs` module to make life a little easier.\n\n\n  let pathWithQs = url.pathname;\n\n  if (config.params && Object.keys(config.params).length > 0) {\n    const q = qs.stringify(opts.params);\n    pathWithQs += `?${q}`;\n  } // Assemble the headers based on basic HTTP2 primitives (path, method) and\n  // custom headers sent from the consumer.  Note: I am using `Object.assign`\n  // here making the assumption these objects are not deep.  If it turns out\n  // they are, we may need to use the `extend` npm module for deep cloning.\n\n\n  const headers = Object.assign({}, opts.headers, {\n    [HTTP2_HEADER_PATH]: pathWithQs,\n    [HTTP2_HEADER_METHOD]: config.method || 'GET'\n  }); // NOTE: This is working around an upstream bug in `apirequest.ts`. The\n  // request path assumes that the `content-type` header is going to be set in\n  // the underlying HTTP Client. This hack provides bug for bug compatability\n  // with this bug in gaxios:\n  // https://github.com/googleapis/gaxios/blob/master/src/gaxios.ts#L202\n\n  if (!headers[HTTP2_HEADER_CONTENT_TYPE]) {\n    if (opts.responseType !== 'text') {\n      headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/json';\n    }\n  }\n\n  const res = {\n    config,\n    request: {},\n    headers: [],\n    status: 0,\n    data: {},\n    statusText: ''\n  };\n  const chunks = [];\n  const session = sessionData.session;\n  let req;\n  return new Promise((resolve, reject) => {\n    try {\n      req = session.request(headers).on('response', headers => {\n        res.headers = headers;\n        res.status = Number(headers[HTTP2_HEADER_STATUS]);\n        let stream = req;\n\n        if (headers[HTTP2_HEADER_CONTENT_ENCODING] === 'gzip') {\n          stream = req.pipe(zlib.createGunzip());\n        }\n\n        if (opts.responseType === 'stream') {\n          res.data = stream;\n          resolve(res);\n          return;\n        }\n\n        stream.on('data', d => {\n          chunks.push(d);\n        }).on('error', err => {\n          reject(err);\n          return;\n        }).on('end', () => {\n          const buf = Buffer.concat(chunks); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          let data = buf;\n\n          if (buf) {\n            if (opts.responseType === 'json') {\n              try {\n                data = JSON.parse(buf.toString('utf8'));\n              } catch (_a) {\n                data = buf.toString('utf8');\n              }\n            } else if (opts.responseType === 'text') {\n              data = buf.toString('utf8');\n            } else if (opts.responseType === 'arraybuffer') {\n              data = buf.buffer;\n            }\n\n            res.data = data;\n          }\n\n          if (!opts.validateStatus(res.status)) {\n            let message = `Request failed with status code ${res.status}. `;\n\n            if (res.data && typeof res.data === 'object') {\n              const body = util.inspect(res.data, {\n                depth: 5\n              });\n              message = `${message}\\n'${body}`;\n            }\n\n            reject(new common_1.GaxiosError(message, opts, res));\n          }\n\n          resolve(res);\n          return;\n        });\n      }).on('error', e => {\n        reject(e);\n        return;\n      });\n    } catch (e) {\n      closeSession(url);\n      reject(e);\n    }\n\n    res.request = req; // If data was provided, write it to the request in the form of\n    // a stream, string data, or a basic object.\n\n    if (config.data) {\n      if (config.data instanceof stream_1.Stream) {\n        config.data.pipe(req);\n      } else if (typeof config.data === 'string') {\n        const data = Buffer.from(config.data);\n        req.end(data);\n      } else if (typeof config.data === 'object') {\n        const data = JSON.stringify(config.data);\n        req.end(data);\n      }\n    } // Create a timeout so the Http2Session will be cleaned up after\n    // a period of non-use. 500 milliseconds was chosen because it's\n    // a nice round number, and I don't know what would be a better\n    // choice. Keeping this channel open will hold a file descriptor\n    // which will prevent the process from exiting.\n\n\n    sessionData.timeoutHandle = setTimeout(() => {\n      closeSession(url);\n    }, 500);\n  });\n}\n\nexports.request = request;\n/**\n * By default, throw for any non-2xx status code\n * @param status - status code from the HTTP response\n */\n\nfunction validateStatus(status) {\n  return status >= 200 && status < 300;\n}\n/**\n * Obtain an existing h2 session or go create a new one.\n * @param host - The hostname to which the session belongs.\n */\n\n\nfunction _getClient(host) {\n  if (!exports.sessions[host]) {\n    if (DEBUG) {\n      console.log(`Creating client for ${host}`);\n    }\n\n    const session = http2.connect(`https://${host}`);\n    session.on('error', e => {\n      console.error(`*ERROR*: ${e}`);\n      delete exports.sessions[host];\n    }).on('goaway', (errorCode, lastStreamId) => {\n      console.error(`*GOAWAY*: ${errorCode} : ${lastStreamId}`);\n      delete exports.sessions[host];\n    });\n    exports.sessions[host] = {\n      session\n    };\n  } else {\n    if (DEBUG) {\n      console.log(`Used cached client for ${host}`);\n    }\n  }\n\n  return exports.sessions[host];\n}\n\nasync function closeSession(url) {\n  const sessionData = exports.sessions[url.host];\n\n  if (!sessionData) {\n    return;\n  }\n\n  const {\n    session\n  } = sessionData;\n  delete exports.sessions[url.host];\n\n  if (DEBUG) {\n    console.error(`Closing ${url.host}`);\n  }\n\n  session.close(() => {\n    if (DEBUG) {\n      console.error(`Closed ${url.host}`);\n    }\n  });\n  setTimeout(() => {\n    if (session && !session.destroyed) {\n      if (DEBUG) {\n        console.log(`Forcing close ${url.host}`);\n      }\n\n      if (session) {\n        session.destroy();\n      }\n    }\n  }, 1000);\n}\n\nexports.closeSession = closeSession;","map":{"version":3,"sources":["/Users/evankiser/Desktop/React/PubTasks/client/node_modules/googleapis-common/build/src/http2.js"],"names":["Object","defineProperty","exports","value","closeSession","request","sessions","http2","require","zlib","url_1","qs","extend","stream_1","util","process","common_1","HTTP2_HEADER_CONTENT_ENCODING","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_STATUS","constants","DEBUG","env","HTTP2_DEBUG","warned","config","message","emitWarning","opts","validateStatus","responseType","url","URL","sessionData","_getClient","host","timeoutHandle","undefined","clearTimeout","pathWithQs","pathname","params","keys","length","q","stringify","headers","assign","method","res","status","data","statusText","chunks","session","req","Promise","resolve","reject","on","Number","stream","pipe","createGunzip","d","push","err","buf","Buffer","concat","JSON","parse","toString","_a","buffer","body","inspect","depth","GaxiosError","e","Stream","from","end","setTimeout","console","log","connect","error","errorCode","lastStreamId","close","destroyed","destroy"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.closeSession = exports.request = exports.sessions = void 0;\nconst http2 = require(\"http2\");\nconst zlib = require(\"zlib\");\nconst url_1 = require(\"url\");\nconst qs = require(\"qs\");\nconst extend = require(\"extend\");\nconst stream_1 = require(\"stream\");\nconst util = require(\"util\");\nconst process = require(\"process\");\nconst common_1 = require(\"gaxios/build/src/common\");\nconst { HTTP2_HEADER_CONTENT_ENCODING, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS, } = http2.constants;\nconst DEBUG = !!process.env.HTTP2_DEBUG;\n/**\n * List of sessions current in use.\n * @private\n */\nexports.sessions = {};\nlet warned = false;\n/**\n * Public method to make an http2 request.\n * @param config - Request options.\n */\nasync function request(config) {\n    // Make sure users know this API is unstable\n    if (!warned) {\n        const message = `\n      The HTTP/2 API in googleapis is unstable! This is an early implementation\n      that should not be used in production.  It may change in unpredictable\n      ways. Please only use this for experimentation.\n    `;\n        process.emitWarning(message, 'GOOG_HTTP2');\n        warned = true;\n    }\n    const opts = extend(true, {}, config);\n    opts.validateStatus = opts.validateStatus || validateStatus;\n    opts.responseType = opts.responseType || 'json';\n    const url = new url_1.URL(opts.url);\n    // Check for an existing session to this host, or go create a new one.\n    const sessionData = _getClient(url.host);\n    // Since we're using this session, clear the timeout handle to ensure\n    // it stays in memory and connected for a while further.\n    if (sessionData.timeoutHandle !== undefined) {\n        clearTimeout(sessionData.timeoutHandle);\n    }\n    // Assemble the querystring based on config.params.  We're using the\n    // `qs` module to make life a little easier.\n    let pathWithQs = url.pathname;\n    if (config.params && Object.keys(config.params).length > 0) {\n        const q = qs.stringify(opts.params);\n        pathWithQs += `?${q}`;\n    }\n    // Assemble the headers based on basic HTTP2 primitives (path, method) and\n    // custom headers sent from the consumer.  Note: I am using `Object.assign`\n    // here making the assumption these objects are not deep.  If it turns out\n    // they are, we may need to use the `extend` npm module for deep cloning.\n    const headers = Object.assign({}, opts.headers, {\n        [HTTP2_HEADER_PATH]: pathWithQs,\n        [HTTP2_HEADER_METHOD]: config.method || 'GET',\n    });\n    // NOTE: This is working around an upstream bug in `apirequest.ts`. The\n    // request path assumes that the `content-type` header is going to be set in\n    // the underlying HTTP Client. This hack provides bug for bug compatability\n    // with this bug in gaxios:\n    // https://github.com/googleapis/gaxios/blob/master/src/gaxios.ts#L202\n    if (!headers[HTTP2_HEADER_CONTENT_TYPE]) {\n        if (opts.responseType !== 'text') {\n            headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/json';\n        }\n    }\n    const res = {\n        config,\n        request: {},\n        headers: [],\n        status: 0,\n        data: {},\n        statusText: '',\n    };\n    const chunks = [];\n    const session = sessionData.session;\n    let req;\n    return new Promise((resolve, reject) => {\n        try {\n            req = session\n                .request(headers)\n                .on('response', headers => {\n                res.headers = headers;\n                res.status = Number(headers[HTTP2_HEADER_STATUS]);\n                let stream = req;\n                if (headers[HTTP2_HEADER_CONTENT_ENCODING] === 'gzip') {\n                    stream = req.pipe(zlib.createGunzip());\n                }\n                if (opts.responseType === 'stream') {\n                    res.data = stream;\n                    resolve(res);\n                    return;\n                }\n                stream\n                    .on('data', d => {\n                    chunks.push(d);\n                })\n                    .on('error', err => {\n                    reject(err);\n                    return;\n                })\n                    .on('end', () => {\n                    const buf = Buffer.concat(chunks);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    let data = buf;\n                    if (buf) {\n                        if (opts.responseType === 'json') {\n                            try {\n                                data = JSON.parse(buf.toString('utf8'));\n                            }\n                            catch (_a) {\n                                data = buf.toString('utf8');\n                            }\n                        }\n                        else if (opts.responseType === 'text') {\n                            data = buf.toString('utf8');\n                        }\n                        else if (opts.responseType === 'arraybuffer') {\n                            data = buf.buffer;\n                        }\n                        res.data = data;\n                    }\n                    if (!opts.validateStatus(res.status)) {\n                        let message = `Request failed with status code ${res.status}. `;\n                        if (res.data && typeof res.data === 'object') {\n                            const body = util.inspect(res.data, { depth: 5 });\n                            message = `${message}\\n'${body}`;\n                        }\n                        reject(new common_1.GaxiosError(message, opts, res));\n                    }\n                    resolve(res);\n                    return;\n                });\n            })\n                .on('error', e => {\n                reject(e);\n                return;\n            });\n        }\n        catch (e) {\n            closeSession(url);\n            reject(e);\n        }\n        res.request = req;\n        // If data was provided, write it to the request in the form of\n        // a stream, string data, or a basic object.\n        if (config.data) {\n            if (config.data instanceof stream_1.Stream) {\n                config.data.pipe(req);\n            }\n            else if (typeof config.data === 'string') {\n                const data = Buffer.from(config.data);\n                req.end(data);\n            }\n            else if (typeof config.data === 'object') {\n                const data = JSON.stringify(config.data);\n                req.end(data);\n            }\n        }\n        // Create a timeout so the Http2Session will be cleaned up after\n        // a period of non-use. 500 milliseconds was chosen because it's\n        // a nice round number, and I don't know what would be a better\n        // choice. Keeping this channel open will hold a file descriptor\n        // which will prevent the process from exiting.\n        sessionData.timeoutHandle = setTimeout(() => {\n            closeSession(url);\n        }, 500);\n    });\n}\nexports.request = request;\n/**\n * By default, throw for any non-2xx status code\n * @param status - status code from the HTTP response\n */\nfunction validateStatus(status) {\n    return status >= 200 && status < 300;\n}\n/**\n * Obtain an existing h2 session or go create a new one.\n * @param host - The hostname to which the session belongs.\n */\nfunction _getClient(host) {\n    if (!exports.sessions[host]) {\n        if (DEBUG) {\n            console.log(`Creating client for ${host}`);\n        }\n        const session = http2.connect(`https://${host}`);\n        session\n            .on('error', e => {\n            console.error(`*ERROR*: ${e}`);\n            delete exports.sessions[host];\n        })\n            .on('goaway', (errorCode, lastStreamId) => {\n            console.error(`*GOAWAY*: ${errorCode} : ${lastStreamId}`);\n            delete exports.sessions[host];\n        });\n        exports.sessions[host] = { session };\n    }\n    else {\n        if (DEBUG) {\n            console.log(`Used cached client for ${host}`);\n        }\n    }\n    return exports.sessions[host];\n}\nasync function closeSession(url) {\n    const sessionData = exports.sessions[url.host];\n    if (!sessionData) {\n        return;\n    }\n    const { session } = sessionData;\n    delete exports.sessions[url.host];\n    if (DEBUG) {\n        console.error(`Closing ${url.host}`);\n    }\n    session.close(() => {\n        if (DEBUG) {\n            console.error(`Closed ${url.host}`);\n        }\n    });\n    setTimeout(() => {\n        if (session && !session.destroyed) {\n            if (DEBUG) {\n                console.log(`Forcing close ${url.host}`);\n            }\n            if (session) {\n                session.destroy();\n            }\n        }\n    }, 1000);\n}\nexports.closeSession = closeSession;\n//# sourceMappingURL=http2.js.map"]},"metadata":{},"sourceType":"script"}